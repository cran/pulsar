<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Zachary D. Kurtz" />


<title>Graphical model selection with pulsar</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Graphical model selection with pulsar</h1>
<h4 class="author">Zachary D. Kurtz</h4>



<div id="table-of-contents" class="section level2">
<h2>Table of Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#basic-usage">Basic usage</a></li>
<li><a href="#using-a-custom-graphical-model-method">Custom
methods</a></li>
<li><a href="#graphlet-stability">Graphlet stability</a></li>
<li><a href="#batch-mode">Batch Mode</a>
<ul>
<li><a href="#notes-on-batch-mode">Notes</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Probabilistic graphical models (<span class="citation">Lauritzen
(1996)</span>) have become an important scientific tool for finding and
describing patterns in high-dimensional data. Learning a graphical model
from data requires a simultaneous estimation of the graph and of the
probability distribution that factorizes according to this graph. In the
Gaussian case, the underlying graph is determined by the non-zero
entries of the precision matrix (the inverse of the population
covariance matrix). Gaussian graphical models have become popular after
the advent of computationally tractable estimators, such as neighborhood
selection (<span class="citation">Meinshausen and Bühlmann
(2010)</span>) and sparse inverse covariance estimation (<span class="citation">Banerjee, El Ghaoui, and D’Aspremont (2008)</span>,
<span class="citation">Yuan and Lin (2007)</span>). State-of-the-art
solvers are the Graphical Lasso (GLASSO) (<span class="citation">Friedman, Hastie, and Tibshirani (2008)</span>) and the
QUadratic approximation for sparse Inverse Covariance estimation (QUIC)
method (<span class="citation">Hsieh et al. (2014)</span>).</p>
<p>Any neighborhood selection and inverse covariance estimation method
requires a careful calibration of a regularization parameter “λ”
(lambda) because the actual model complexity is not known a priori.
State-of-the- art tuning parameter calibration schemes include
cross-validation, (extended) information criteria (IC) such as Akaike IC
and Bayesian IC (<span class="citation">Yuan and Lin (2007)</span>;
<span class="citation">Foygel and Drton (2010)</span>), and the
Stability Approach to Regularization Selection (StARS) (<span class="citation">Liu, Roeder, and Wasserman (2010)</span>). The StARS
method is particularly appealing because it shows superior empirical
performance on synthetic and real-world test cases and has a clear
interpretation: StARS seeks the minimum amount of regularization that
results in a sparse graph whose edge set is reproducible under random
subsampling of the data at a fixed proportion β (<span class="citation">Zhao, Liu, and Roeder (2012)</span>). Regularization
parameter selection is thus determined by the concept of stability
rather than regularization strength.</p>
<p>Two major shortcomings in StARS are computational cost and optimal
setting of beta. StARS must repeatedly solve costly global optimization
problems (neighborhood or sparse inverse covariance selection) over the
entire regularization path for N sets of subsamples (where the choice of
N is user-defined). Also, there may be no universally optimal setting of
β as edge stability is strongly influenced by the underlying unknown
topology of the graph (<span class="citation">Ravikumar et al.
(2011)</span>).</p>
<p>We alleviated both of these shortcomings (see <span class="citation">Müller, Bonneau, and Kurtz (2016)</span>). Firstly, we
speed up StARS by proposing β-dependent lower and upper bounds on the
regularization path from as few as N = 2 subsamples (Bounded StARS
(B-StARS)). This implies that the lower part of regularization path
(resulting in dense graphs and hence computationally expensive
optimization) does not need to be explored for future samples without
compromising selection quality. Secondly, we generalized the concept of
edge stability to induced subgraph (graphlet) stability. We use the
graphlet correlation distance (gcd) (<span class="citation">Yaveroglu et
al. (2014)</span>) as a novel variability measure for small induced
subgraphs across graph estimates. Requiring simultaneously edge and
graphlet stability (gcd+StARS or G-StARS) leads to superior
regularization parameter selection on synthetic benchmarks and
real-world data.</p>
<p>The pulsar package comprises <strong>p</strong>arallelized
<strong>u</strong>tilities for <strong>l</strong>ambda
<strong>s</strong>election <strong>a</strong>long a
<strong>r</strong>egularization path using the StARS methodology and our
recent extensions. Pulsar includes additional options for speedups,
parallelizations and complementary metrics (e.g., graphlet stability
(gcd), natural connectivity, …). This R package uses function passing to
allow you to use your favorite graphical model learning method (e.g,
GLASSO, neighborhood selection, QUIC, clime, etc). Since the tools are
quite generic, pulsar can be used for other regularized problem
formulations, e.g., for regularized regression (with the LASSO) or by
using other sparsity-inducing norms (e.g., SCAD, MCP, …)</p>
<p>The option to find lower/upper bounds on the StARS-selected lambda
from N=2 subsamples works particularly well when the underlying target
graphs are sparse or when the dimensionality is high (above 20 variables
or so). The bounds greatly reduce computational burden even when running
in embarrassingly parallel (batch) mode.</p>
<p>In batch computing systems, we use the <a href="https://cran.r-project.org/package=batchtools">batchtools</a>
Map/Reduce strategy (for batch computing systems such as Torque, LSF,
SLURM or SGE) and well as Interactive and multicore, socket, ssh
clusters and Docker swams. which can significantly reduce the
computation and memory burdens for StARS. This is useful for hpc users,
when the number of processors available on a multicore machine would
otherwise allow for only modest parallelization.</p>
<p>Please see the paper preprint on <a href="https://arxiv.org/abs/1605.07072">arXiv</a>.</p>
</div>
<div id="installation" class="section level2">
<h2>Installation</h2>
<p>The most recent version of pulsar is on <a href="https://github.com/zdk123/pulsar">github</a> and installation
requires the devtools package. For the purposes of this tutorial
suggested but not-imported packages will be prompted as needed
(e.g. <code>huge</code>, <code>orca</code>, …).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages(&#39;pulsar&#39;)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="do">## uncomment below for the dev version</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># library(devtools)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># install_github(&quot;zdk123/pulsar&quot;)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(pulsar)</span></code></pre></div>
</div>
<div id="basic-usage" class="section level2">
<h2>Basic usage</h2>
<p>In this example, we will use synthetic data generated from the
<code>huge</code> package.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(huge)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">10010</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="dv">40</span> ; n <span class="ot">&lt;-</span> <span class="dv">3000</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>dat  <span class="ot">&lt;-</span> <span class="fu">huge.generator</span>(n, p, <span class="st">&quot;hub&quot;</span>, <span class="at">verbose=</span><span class="cn">FALSE</span>, <span class="at">v=</span>.<span class="dv">1</span>, <span class="at">u=</span>.<span class="dv">5</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>lmax <span class="ot">&lt;-</span> <span class="fu">getMaxCov</span>(dat<span class="sc">$</span>sigmahat)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>lams <span class="ot">&lt;-</span> <span class="fu">getLamPath</span>(lmax, lmax<span class="sc">*</span>.<span class="dv">05</span>, <span class="at">len=</span><span class="dv">40</span>)</span></code></pre></div>
<p>You can use the <code>pulsar</code> package to run StARS, serially,
as a drop-in replacement for the <code>huge.select</code> function in
the <code>huge</code> package. Pulsar differs in that we run the model
selection step first and then refit using arguments stored in the
original call. Remove the <code>seed</code> argument for real data (this
seeds the pseudo-random number generator to fix subsampling for
reproducing test code).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>hugeargs <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">lambda=</span>lams, <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>time1    <span class="ot">&lt;-</span> <span class="fu">system.time</span>(</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>out.p    <span class="ot">&lt;-</span> <span class="fu">pulsar</span>(dat<span class="sc">$</span>data, <span class="at">fun=</span>huge, <span class="at">fargs=</span>hugeargs, <span class="at">rep.num=</span><span class="dv">20</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">criterion=</span><span class="st">&#39;stars&#39;</span>, <span class="at">seed=</span><span class="dv">10010</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>fit.p    <span class="ot">&lt;-</span> <span class="fu">refit</span>(out.p)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="do">## Inspect the output ##</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>out.p</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>fit.p</span></code></pre></div>
<p>Including the lower bound option <code>lb.stars</code> and upper
bound option <code>ub.stars</code> can improve runtime for same StARS
result (referred to as B-StARS in Mueller et al., 2016).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>time2 <span class="ot">&lt;-</span> <span class="fu">system.time</span>(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>out.b <span class="ot">&lt;-</span> <span class="fu">pulsar</span>(dat<span class="sc">$</span>data, <span class="at">fun=</span>huge, <span class="at">fargs=</span>hugeargs, <span class="at">rep.num=</span><span class="dv">20</span>,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>          <span class="at">criterion=</span><span class="st">&#39;stars&#39;</span>, <span class="at">lb.stars=</span><span class="cn">TRUE</span>, <span class="at">ub.stars=</span><span class="cn">TRUE</span>, <span class="at">seed=</span><span class="dv">10010</span>))</span></code></pre></div>
<p>Compare runtimes and StARS-selected lambda index for each method.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>time2[[<span class="dv">3</span>]] <span class="sc">&lt;</span> time1[[<span class="dv">3</span>]]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">opt.index</span>(out.p, <span class="st">&#39;stars&#39;</span>) <span class="sc">==</span> <span class="fu">opt.index</span>(out.b, <span class="st">&#39;stars&#39;</span>)</span></code></pre></div>
</div>
<div id="using-a-custom-graphical-model-method" class="section level2">
<h2>Using a custom graphical model method</h2>
<p>You can pass in an arbitrary graphical model estimation function to
<code>fun</code>. The function has some requirements: the first argument
must be the nxp data matrix, and one argument must be named
<code>lambda</code>, which should be a decreasing numeric vector
containing the lambda path. The output should be a list of adjacency
matrices (which can be of sparse representation from the
<code>Matrix</code> package to save memory). Here is an example from
<code>QUIC</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(BigQuic)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>quicr <span class="ot">&lt;-</span> <span class="cf">function</span>(data, lambda, <span class="at">seed=</span><span class="cn">NULL</span>) {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    est  <span class="ot">&lt;-</span> BigQuic<span class="sc">::</span><span class="fu">BigQuic</span>(data, <span class="at">lambda=</span>lambda, <span class="at">epsilon=</span><span class="fl">1e-2</span>, <span class="at">use_ram=</span><span class="cn">TRUE</span>, <span class="at">seed=</span>seed)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    est <span class="ot">&lt;-</span> <span class="fu">setNames</span>(<span class="fu">lapply</span>(<span class="fu">ls</span>(<span class="at">envir=</span>est), mget, <span class="at">envir=</span><span class="fu">attr</span>(<span class="fu">unclass</span>(est), <span class="st">&#39;.xData&#39;</span>)), <span class="fu">ls</span>(<span class="at">envir=</span>est))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    path <span class="ot">&lt;-</span>  <span class="fu">lapply</span>(<span class="fu">seq</span>(<span class="fu">length</span>(lambda)), <span class="cf">function</span>(i) {</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                tmp <span class="ot">&lt;-</span> est<span class="sc">$</span>precision_matrices[[<span class="dv">1</span>]][[i]]; <span class="fu">diag</span>(tmp) <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                <span class="fu">as</span>(tmp<span class="sc">!=</span><span class="dv">0</span>, <span class="st">&quot;lgCMatrix&quot;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    est<span class="sc">$</span>path <span class="ot">&lt;-</span> path</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    est</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We can use <code>pulsar</code> with a similar call. We can also
parallelize this a bit for multi-processor machines by specifying
<code>ncores</code> (which wraps <code>mclapply</code> in the parallel
package).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>quicargs <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">lambda=</span>lams)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>nc    <span class="ot">&lt;-</span> <span class="cf">if</span> (.Platform<span class="sc">$</span>OS.type <span class="sc">==</span> <span class="st">&#39;unix&#39;</span>) <span class="dv">2</span> <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>out.q <span class="ot">&lt;-</span> <span class="fu">pulsar</span>(dat<span class="sc">$</span>data, <span class="at">fun=</span>quicr, <span class="at">fargs=</span>quicargs, <span class="at">rep.num=</span><span class="dv">100</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">criterion=</span><span class="st">&#39;stars&#39;</span>, <span class="at">lb.stars=</span><span class="cn">TRUE</span>, <span class="at">ub.stars=</span><span class="cn">TRUE</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">ncores=</span>nc, <span class="at">seed=</span><span class="dv">10010</span>)</span></code></pre></div>
</div>
<div id="graphlet-stability" class="section level2">
<h2>Graphlet stability</h2>
<p>We can use the graphlet correlation distance (gcd) as an additional
stability criterion (G-StARS). We could call <code>pulsar</code> again
with a new criterion, or simply <code>update</code> the arguments for
model we already used. Then, we can use our default approach for
selecting the optimal index, based on the gcd+StARS criterion: choose
the minimum gcd summary statistic between the upper and lower StARS
bounds.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>out.q2 <span class="ot">&lt;-</span> <span class="fu">update</span>(out.q, <span class="at">criterion=</span><span class="fu">c</span>(<span class="st">&#39;stars&#39;</span>, <span class="st">&#39;gcd&#39;</span>))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">opt.index</span>(out.q2, <span class="st">&#39;gcd&#39;</span>) <span class="ot">&lt;-</span> <span class="fu">get.opt.index</span>(out.q2, <span class="st">&#39;gcd&#39;</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>fit.q2 <span class="ot">&lt;-</span> <span class="fu">refit</span>(out.q2)</span></code></pre></div>
<p>Compare model error by relative Hamming distances between refit
adjacency matrices and the true graph and visualize the results:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out.q2, <span class="at">scale=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>starserr <span class="ot">&lt;-</span> <span class="fu">sum</span>(fit.q2<span class="sc">$</span>refit<span class="sc">$</span>stars <span class="sc">!=</span> dat<span class="sc">$</span>theta)<span class="sc">/</span>p<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>gcderr   <span class="ot">&lt;-</span> <span class="fu">sum</span>(fit.q2<span class="sc">$</span>refit<span class="sc">$</span>gcd   <span class="sc">!=</span> dat<span class="sc">$</span>theta)<span class="sc">/</span>p<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>gcderr <span class="sc">&lt;</span> starserr</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="do">## install.packages(&#39;network&#39;)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>truenet  <span class="ot">&lt;-</span> network<span class="sc">::</span><span class="fu">network</span>(<span class="fu">as.matrix</span>(dat<span class="sc">$</span>theta))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>starsnet <span class="ot">&lt;-</span> network<span class="sc">::</span><span class="fu">network</span>(<span class="fu">summary</span>(fit.q2<span class="sc">$</span>refit<span class="sc">$</span>stars))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>gcdnet   <span class="ot">&lt;-</span> network<span class="sc">::</span><span class="fu">network</span>(<span class="fu">summary</span>(fit.q2<span class="sc">$</span>refit<span class="sc">$</span>gcd))</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>coords <span class="ot">&lt;-</span> <span class="fu">plot</span>(truenet, <span class="at">usearrows=</span><span class="cn">FALSE</span>, <span class="at">main=</span><span class="st">&quot;TRUE&quot;</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(starsnet, <span class="at">coord=</span>coords, <span class="at">usearrows=</span><span class="cn">FALSE</span>, <span class="at">main=</span><span class="st">&quot;StARS&quot;</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(gcdnet, <span class="at">coord=</span>coords, <span class="at">usearrows=</span><span class="cn">FALSE</span>, <span class="at">main=</span><span class="st">&quot;gcd+StARS&quot;</span>)</span></code></pre></div>
</div>
<div id="batch-mode" class="section level2">
<h2>Batch Mode</h2>
<p>For large graphs, we could reduce <code>pulsar</code> run time by
running each subsampled dataset in parallel (i.e., each run as an
independent job). This is a natural choice since we want to infer an
independent graphical model for each subsampled dataset.</p>
<p>Enter <a href="https://mllg.github.io/batchtools/articles/batchtools.html">batchtools</a>.
This package lets us invoke the queuing system in a high performance
computing (hpc) environment so that we don’t have to worry about any of
the job-handling procedures in R.</p>
<p><code>pulsar</code> has only been tested for Torque so far, but
should work without too much effort for LSF, SLURM, SGE, …</p>
<p>We also potentially gain efficiency in memory usage. Even for memory
efficient representations of sparse graphs, for a lambda path of size L
and for number N subsamples we must hold <code>L*N</code>
<code>p*p</code>- sized adjacency matrices in memory to compute the
summary statistic. batchtools lets us use a MapReduce strategy, so that
only one <code>p*p</code> graph and one <code>p*p</code> aggregation
matrix needs to be held in memory at any time. For large p, it can be
more efficient to read data off the disk.</p>
<p>This also means we will need access to a writable directory to write
intermediate files (where the batchtools registry is stored). These will
be automatically generated R scripts, error and output files and sqlite
files so that batchtools can keep track of everything (although a
different database can be used). Please see that package’s documentation
for more information. By default, <code>pulsar</code> will create the
registry directory under R’s (platform-dependent) tmp directory but this
can be overridden(<code>regdir</code> argument to
<code>batch.pulsar</code>).</p>
<p>For generating batchtools, we need a configuration file (supply a
path string to <code>conffile</code> argument, a good choice is the
working directory) and, for an hpc with a queuing system, a template
file. Example config (batchtools.conf.torque.R) and PBS template file
(simpletorque.tmpl) for Torque can be found in the inst/config/ and
inst/templates/ subdirectories of this repo, respectively. See the <a href="https://mllg.github.io/batchtools/articles/batchtools.html">batchtools
help page</a> for creating templates for other systems.</p>
<p>For this example I suggest using batchtools interactive clusters
(serial) mode to get things up and running. The necessary config file is
included in this package.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>conffile <span class="ot">&lt;-</span> pulsar<span class="sc">::</span><span class="fu">findConfFile</span>()</span></code></pre></div>
<p>Since batchtools is not imported by <code>pulsar</code>, it needs to
be loaded. Verbosity and progressbar options for batchtools is set by
global options. Uncomment <code>cleanup=TRUE</code> to remove registry
directory (useful if running through the example code multiple
times).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="do">## uncomment below if batchtools is not already installed</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co"># install.packages(&#39;batchtools&#39;)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(batchtools)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="fu">options</span>(<span class="at">batchtools.progress=</span><span class="cn">TRUE</span>, <span class="at">batchtools.verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>out.batch <span class="ot">&lt;-</span> <span class="fu">batch.pulsar</span>(dat<span class="sc">$</span>data, <span class="at">fun=</span>quicr, <span class="at">fargs=</span>quicargs, <span class="at">rep.num=</span><span class="dv">100</span>,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                          <span class="at">criterion=</span><span class="st">&#39;stars&#39;</span>, <span class="at">seed=</span><span class="dv">10010</span> <span class="co">#, cleanup=TRUE</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                         )</span></code></pre></div>
<p>Check that we get the same result from batch mode pulsar:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">opt.index</span>(out.q, <span class="st">&#39;stars&#39;</span>) <span class="sc">==</span> <span class="fu">opt.index</span>(out.batch, <span class="st">&#39;stars&#39;</span>)</span></code></pre></div>
<p>It is also possible to run B-StARS in batch. The first two jobs
(representing the first 2 subsamples) will run to completion before the
final N-2 are run. This serializes the batch mode a bit but is, in
general, faster whenever individual jobs require costly computation
outside the lambda bounds, e.g., when some of the provided lambda values
along the regularization path induce dense graph estimates.</p>
<p>To keep the initial two jobs separate from the rest, the string
provided to the <code>init</code> argument (“subtwo” by default) is
concatenated to the basename of <code>regdir</code>. The registry/id is
returned but named <code>init.reg</code> and <code>init.id</code> from
<code>batch.pulsar</code>. If missing (the default), a random string is
used for both registries.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>out.bbatch <span class="ot">&lt;-</span> <span class="fu">update</span>(out.batch, <span class="at">criterion=</span><span class="fu">c</span>(<span class="st">&#39;stars&#39;</span>, <span class="st">&#39;gcd&#39;</span>),</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">lb.stars=</span><span class="cn">TRUE</span>, <span class="at">ub.stars=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p>Check that we get the same result from bounded/batch mode pulsar:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">opt.index</span>(out.bbatch, <span class="st">&#39;stars&#39;</span>) <span class="sc">==</span> <span class="fu">opt.index</span>(out.batch, <span class="st">&#39;stars&#39;</span>)</span></code></pre></div>
<div id="notes-on-batch-mode" class="section level3">
<h3>Notes on batch mode</h3>
<ul>
<li><p>In real applications, on an hpc, it is important to specify the
<code>res.list</code> argument, which is a <strong>named</strong> list
of PBS resources that matches the template file. For example if using
the simpletorque.tml file provided <a href="https://raw.githubusercontent.com/zdk123/pulsar/master/inst/templates/simpletorque.tmpl">here</a>
one would provide
<code>res.list=list(walltime=&quot;4:00:00&quot;, nodes=&quot;1&quot;, memory=&quot;1gb&quot;)</code>
to give the PBS script 4 hours and 1GB of memory and 1 node to the
resource list for <code>qsub</code>.</p></li>
<li><p>Gains in efficiency and run time (especially when paired with
lower/upper bound mode) will largely depend on your hpc setup. E.g - do
you have sufficient priority in the queue to run your 100 jobs in
perfect parallel? Because settings vary so widely, we cannot provide
support for unexpected hpc problems or make specific recommendations
about requesting the appropriate resource requirements for
jobs.</p></li>
<li><p>One final note: we assume that a small number of jobs could fail
at random. If jobs fail to complete, a warning will be given, but
<code>pulsar</code> will complete the run and summary statistics will be
computed only over the successful jobs (with normalization constants
appropriately adjusted). It is up to the user to re-start
<code>pulsar</code> if there is a sampling-dependent reason for job
failure, e.g., when an outlier data point increases computation time or
graph density and insufficient resources are allocated.</p></li>
</ul>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Banerjee2008" class="csl-entry">
Banerjee, Onureena, Laurent El Ghaoui, and Alexandre D’Aspremont. 2008.
<span>“<span class="nocase">Model selection through sparse maximum
likelihood estimation for multivariate gaussian or binary
data</span>.”</span> <em>The Journal of Machine <span>…</span></em> 9:
485–516. <a href="https://dl.acm.org/doi/10.5555/1390681.1390696">https://dl.acm.org/doi/10.5555/1390681.1390696</a>.
</div>
<div id="ref-Foygel2010" class="csl-entry">
Foygel, Rina, and Mathias Drton. 2010. <span>“<span class="nocase">Extended Bayesian Information Criteria for Gaussian
Graphical Models</span>.”</span> <em>Arxiv Preprint</em>, 1–14. <a href="https://arxiv.org/abs/1011.6640">https://arxiv.org/abs/1011.6640</a>.
</div>
<div id="ref-Friedman2008" class="csl-entry">
Friedman, Jerome, Trevor Hastie, and Robert Tibshirani. 2008.
<span>“<span class="nocase">Sparse inverse covariance estimation with
the graphical lasso.</span>”</span> <em>Biostatistics (Oxford,
England)</em> 9 (3): 432–41.
</div>
<div id="ref-Hsieh2014" class="csl-entry">
Hsieh, Cho-Jui, Mátyás A Sustik, Inderjit S Dhillon, and Pradeep
Ravikumar. 2014. <span>“<span class="nocase">QUIC: Quadratic
Approximation for Sparse Inverse Covariance Estimation</span>.”</span>
<em>Journal of Machine Learning Research</em> 15: 2911–47. <a href="https://jmlr.org/papers/v15/hsieh14a.html">https://jmlr.org/papers/v15/hsieh14a.html</a>.
</div>
<div id="ref-Lauritzen:1996" class="csl-entry">
Lauritzen, Steffen L. 1996. <em><span class="nocase">Graphical
models</span></em>. Oxford University Press.
</div>
<div id="ref-Liu2010" class="csl-entry">
Liu, Han, Kathryn Roeder, and Larry Wasserman. 2010. <span>“<span class="nocase">Stability approach to regularization selection (stars)
for high dimensional graphical models</span>.”</span> <em>Proceedings of
the Twenty-Third Annual Conference on Neural Information Processing
Systems (NIPS)</em>, 1–14. <a href="https://papers.nips.cc/paper/3966-stability-approach-to-regularization-selection-stars-for-high-dimensional-graphical-models.pdf">https://papers.nips.cc/paper/3966-stability-approach-to-regularization-selection-stars-for-high-dimensional-graphical-models.pdf</a>.
</div>
<div id="ref-Meinshausen:2010" class="csl-entry">
Meinshausen, N, and P Bühlmann. 2010. <span>“<span class="nocase">Stability selection</span>.”</span> <em>J. R. Stat. Soc.
Ser. B Stat. Methodol.</em> 72 (4): 417–73.
</div>
<div id="ref-Mueller:2016" class="csl-entry">
Müller, Christian L., Richard Bonneau, and Zachary Kurtz. 2016.
<span>“Generalized Stability Approach for Regularized Graphical
Models.”</span>
</div>
<div id="ref-Ravikumar2011b" class="csl-entry">
Ravikumar, Pradeep, Martin J. Wainwright, Garvesh Raskutti, and Bin Yu.
2011. <span>“<span class="nocase">High-dimensional covariance estimation
by minimizing L1 -penalized log-determinant divergence</span>.”</span>
<em>Electronic Journal of Statistics</em> 5 (January 2010): 935–80.
</div>
<div id="ref-Yaveroglu2014" class="csl-entry">
Yaveroglu, Ömer Nebil, Noël Malod-Dognin, Darren Davis, Zoran Levnajic,
Vuk Janjic, Rasa Karapandza, Aleksandar Stojmirovic, and Nataša Pržulj.
2014. <span>“<span class="nocase">Revealing the hidden language of
complex networks.</span>”</span> <em>Scientific Reports</em> 4
(January): 4547. <a href="https://doi.org/10.1038/srep04547">https://doi.org/10.1038/srep04547</a>.
</div>
<div id="ref-Yuan:2007" class="csl-entry">
Yuan, Ming, and Yi Lin. 2007. <span>“<span class="nocase">Model
selection and estimation in the Gaussian graphical model</span>.”</span>
<em>Biometrika</em> 94 (1): 19–35. <a href="https://doi.org/10.1093/biomet/asm018">https://doi.org/10.1093/biomet/asm018</a>.
</div>
<div id="ref-Zhao2012" class="csl-entry">
Zhao, Tuo, H Liu, and Kathryn Roeder. 2012. <span>“<span class="nocase">The huge package for high-dimensional undirected graph
estimation in r</span>.”</span> <em>The Journal of Machine Learning
Research</em> 13: 1059–62. <a href="https://dl.acm.org/doi/10.5555/2503308.2343681">https://dl.acm.org/doi/10.5555/2503308.2343681</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
